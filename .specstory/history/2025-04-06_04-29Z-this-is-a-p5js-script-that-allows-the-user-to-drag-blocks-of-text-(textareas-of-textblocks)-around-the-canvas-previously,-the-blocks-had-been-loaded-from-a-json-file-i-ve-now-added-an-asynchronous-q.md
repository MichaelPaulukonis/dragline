<!-- Generated by SpecStory -->

<!-- vscode Session 7a98bdee-9fa2-4496-b7fb-f153fe1699ee (2025-04-06 04:29Z) -->

# This is a p5js script that allows the user to drag blocks of text (textAreas of textBlocks) around the canvas. Previously, the blocks had been loaded from a json file. I've now added an asynchronous q (2025-04-06 04:29Z)

_**User (2025-04-06 04:33Z)**_

This is a p5js script that allows the user to drag blocks of text (textAreas of textBlocks) around the canvas. Previously, the blocks had been loaded from a json file. I've now added an asynchronous query to an external website (via tumblrRandomPost) that is then converted to blocks (via gridify).

If the tumblrRandomPost or gridify fails, I'd like to fall back to using the json import.

I'd also like the user to be able to request another query to tumblrRandomPost.

---

_**Assistant**_

### [dragline.js](file:///Users/michaelpaulukonis/projects/dragline/src/dragline.js)

Add error handling for `tumblrRandomPost` and `gridify` to fall back to the JSON import. Also, add functionality to allow the user to request another query to `tumblrRandomPost` by pressing a specific key (e.g., `n`).

````javascript
import '../css/style.css'
await import('p5js-wrapper')
import gridify from './text-grid'
// ...existing code...
const fallbackBlocks = await import('./grids.20250403T123247766Z.json')
import tumblrRandomPost from './tumblr-random'

let corpus
let blocks

async function initializeBlocks() {
  try {
    corpus = await tumblrRandomPost()
    blocks = gridify(corpus.join('\n'))
  } catch (error) {
    console.error('Failed to fetch or process data from tumblrRandomPost. Falling back to JSON import.', error)
    blocks = fallbackBlocks.default
  }
}

await initializeBlocks()

new p5(p => {
  // ...existing code...

  p.keyPressed = async () => {
    if (p.key === 'i' || p.keyCode === p.ESCAPE) {
      toggleInfoBox()
    } else if (p.key === ' ') {
      fillChar = fillChars[(fillChars.indexOf(fillChar) + 1) % fillChars.length]
      display()
    } else if (p.key === 'r') {
      // Clear and replace text areas
      textAreas.length = 0
      setupTextAreas(textAreas) // Reinitialize with new unique blocks
      display()
    } else if (p.keyCode === p.RIGHT_ARROW) {
      // Add a new block
      if (textAreas.length < blocks.length) {
        const usedIndices = new Set(textAreas.map(area => area.index)) // Track used indices
        textAreas.push(createBlock(usedIndices))
        blockCount++
        display()
      }
    } else if (p.keyCode === p.LEFT_ARROW) {
      // Remove the last block (minimum of 1 block)
      if (textAreas.length > 1) {
        textAreas.pop()
        blockCount--
        display()
      }
    } else if (p.key === 'n') {
      // Request another query to tumblrRandomPost
      try {
        corpus = await tumblrRandomPost()
        blocks = gridify(corpus.join('\n'))
        textAreas.length = 0
        setupTextAreas(textAreas) // Reinitialize with new unique blocks
        display()
      } catch (error) {
        console.error('Failed to fetch or process new data from tumblrRandomPost.', error)
      }
    }

    // ...existing code for dragging and reordering...
  }
})
````

### Summary of Changes:
1. Added `initializeBlocks` function to handle asynchronous initialization of `blocks` with a fallback to the JSON import if `tumblrRandomPost` or `gridify` fails.
2. Added a new key handler (`n`) to allow the user to request another query to `tumblrRandomPost`. If the query fails, it logs an error and retains the current state.

---

_**User (2025-04-06 04:35Z)**_

Thanks for adding the key-handler for 'n' ! But shouldn't that use the new initializeBlocks function, so avoid code duplication?

---

_**Assistant**_

### [dragline.js](file:///Users/michaelpaulukonis/projects/dragline/src/dragline.js)

Refactor the `'n'` key handler to use the `initializeBlocks` function to avoid code duplication.

````javascript
// ...existing code...

p.keyPressed = async () => {
  if (p.key === 'i' || p.keyCode === p.ESCAPE) {
    toggleInfoBox()
  } else if (p.key === ' ') {
    fillChar = fillChars[(fillChars.indexOf(fillChar) + 1) % fillChars.length]
    display()
  } else if (p.key === 'r') {
    // Clear and replace text areas
    textAreas.length = 0
    setupTextAreas(textAreas) // Reinitialize with new unique blocks
    display()
  } else if (p.keyCode === p.RIGHT_ARROW) {
    // Add a new block
    if (textAreas.length < blocks.length) {
      const usedIndices = new Set(textAreas.map(area => area.index)) // Track used indices
      textAreas.push(createBlock(usedIndices))
      blockCount++
      display()
    }
  } else if (p.keyCode === p.LEFT_ARROW) {
    // Remove the last block (minimum of 1 block)
    if (textAreas.length > 1) {
      textAreas.pop()
      blockCount--
      display()
    }
  } else if (p.key === 'n') {
    // Request another query to tumblrRandomPost using initializeBlocks
    try {
      await initializeBlocks()
      textAreas.length = 0
      setupTextAreas(textAreas) // Reinitialize with new unique blocks
      display()
    } catch (error) {
      console.error('Failed to fetch or process new data from tumblrRandomPost.', error)
    }
  }

  // ...existing code for dragging and reordering...
}
````

### Summary of Changes:
1. Updated the `'n'` key handler to call `initializeBlocks` instead of duplicating the logic for fetching and processing data.
2. This ensures consistency and reduces code duplication.

---

